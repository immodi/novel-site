package templates

import (
	"immodi/novel-site/internal/config"
	components "immodi/novel-site/internal/http/components/index"
	"immodi/novel-site/internal/http/structs/index"
	"immodi/novel-site/pkg"
)

templ Layout(metaData *indexdtostructs.MetaDataStruct, data *indexdtostructs.LayoutData, content templ.Component) {
	<!DOCTYPE html>
	<html lang="en">
		<head>
			if config.IsProduction {
				@GoogleAnalytics()
			}
			<meta charset="UTF-8"/>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			<!-- <link rel="stylesheet" href="/static/styles/output.css"/> -->
			<link rel="stylesheet" href={ "/static/styles/output.css?v=" + pkg.HashCSS() }/>
			<!-- Multiple favicon formats for better compatibility -->
			<link rel="icon" type="image/x-icon" href="/static/logo/favicon.ico"/>
			<link rel="icon" type="image/png" sizes="48x48" href="/static/logo/logo_icon.png"/>
			<link rel="icon" type="image/svg+xml" href="/static/logo/logo_icon.svg"/>
			<script src="/static/js/htmx.min.js"></script>
			<title>{ metaData.Title }</title>
			@components.MetaHead(metaData)
		</head>
		<body class="min-h-screen flex flex-col">
			@components.Header(
				data.Headers,
			)
			<main class="flex flex-grow">
				@content
			</main>
			@components.Footer()
			@DarkModeScript()
		</body>
	</html>
}

templ DarkModeScript() {
	<script>
    // function applyTheme(isLight) {
    //     document.querySelectorAll("[class*='dark:'], [class*='off:']").forEach(el => {
    //         let classAttr = el.getAttribute("class") || "";
    //         const classes = classAttr.trim().split(/\s+/);
    //
    //         const newClasses = classes.map(c => {
    //             if (c.startsWith("dark:")) {
    //                 return isLight ? c : c.replace("dark:", "off:");
    //             }
    //             if (c.startsWith("off:")) {
    //                 return isLight ? c.replace("off:", "dark:") : c;
    //             }
    //             return c;
    //         }).join(" ");
    //
    //         el.setAttribute("class", newClasses);
    //     });
    //
    //     // Icon switching
    //     const sun = document.getElementById("sun-icon");
    //     const moon = document.getElementById("moon-icon");
    //     if (isLight) {
    //         sun.classList.remove("opacity-0", "scale-75");
    //         moon.classList.add("opacity-0", "scale-75");
    //     } else {
    //         moon.classList.remove("opacity-0", "scale-75");
    //         sun.classList.add("opacity-0", "scale-75");
    //     }
    // }
    //
    // // Load from localStorage
    // let isLight = localStorage.getItem("theme") === "light";
    // applyTheme(isLight);
    //
    // document.querySelector("#toggleDark").addEventListener("click", () => {
    //     console.log(isLight)
    //
    //     isLight = !isLight;
    //     localStorage.setItem("theme", isLight ? "light" : "dark");
    //     applyTheme(isLight);
    // });



    (function () {
        // Utility: process a single element (store original classes once)
        function processElement(el, isLight) {
            if (!el || el.nodeType !== 1) return;
            // Save original classes once so swaps are deterministic
            if (!el.dataset.origClass) {
                el.dataset.origClass = el.getAttribute("class") || "";
            }
            const orig = el.dataset.origClass;
            const classes = orig.trim().split(/\s+/).filter(Boolean);

            const newClasses = classes.map(c => {
                if (c.startsWith("dark:")) {
                    // In light mode => turn dark: -> off: (deactivate dark variant)
                    // In dark mode  => keep as dark:
                    return isLight ? c.replace(/^dark:/, "off:") : c;
                }
                if (c.startsWith("off:")) {
                    // In light mode => turn off: -> dark: (activate the light variant in your scheme)
                    // In dark mode  => keep as off:
                    return isLight ? c.replace(/^off:/, "dark:") : c;
                }
                return c;
            }).join(" ");

            // Only set the class attr if it changed (micro-optimization)
            if (el.getAttribute("class") !== newClasses) {
                el.setAttribute("class", newClasses);
            }
        }

        // Apply to all matching elements (idempotent thanks to dataset.origClass)
        function applyTheme(isLight) {
            document.querySelectorAll("[class*='dark:'], [class*='off:']").forEach(el => {
                processElement(el, isLight);
            });

            // Icon switching (keeps your original approach)
            const sun = document.getElementById("sun-icon");
            const moon = document.getElementById("moon-icon");
            if (sun && moon) {
                if (isLight) {
                    sun.classList.remove("opacity-0", "scale-75");
                    moon.classList.add("opacity-0", "scale-75");
                } else {
                    moon.classList.remove("opacity-0", "scale-75");
                    sun.classList.add("opacity-0", "scale-75");
                }
            }
        }

        // Read preference
        let isLight = localStorage.getItem("theme") === "light";

        // Initial apply
        applyTheme(isLight);

        // Toggle button
        const toggler = document.querySelector("#toggleDark");
        if (toggler) {
            toggler.addEventListener("click", () => {
                isLight = !isLight;
                localStorage.setItem("theme", isLight ? "light" : "dark");
                applyTheme(isLight);
            });
        }

        // Re-apply after HTMX swaps (simple and reliable)
        document.body.addEventListener("htmx:afterSwap", (evt) => {
            // If you want, you can narrow by target: if (evt.detail.target.id === 'comments') ...
            applyTheme(isLight);
        });

        // MutationObserver fallback: process newly-added nodes only
        const observer = new MutationObserver(mutations => {
            for (const m of mutations) {
                for (const node of m.addedNodes) {
                    if (node.nodeType !== 1) continue;
                    // If the added node itself has classes we care about
                    if ((node.getAttribute && /(^|\s)(dark:|off:)/.test(node.getAttribute("class") || ""))) {
                        processElement(node, isLight);
                    }
                    // Also process descendants
                    node.querySelectorAll && node.querySelectorAll("[class*='dark:'], [class*='off:']").forEach(el => {
                        processElement(el, isLight);
                    });
                }
            }
        });

        observer.observe(document.documentElement || document.body, {childList: true, subtree: true});
    })();
</script>
}

templ GoogleAnalytics() {
	<!-- Google tag (gtag.js) -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=G-L48Q73K545"></script>
	<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-L48Q73K545');
</script>
}
