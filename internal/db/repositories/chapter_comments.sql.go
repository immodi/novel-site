// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: chapter_comments.sql

package repositories

import (
	"context"
	"database/sql"
	"strings"
)

const countChapterReactions = `-- name: CountChapterReactions :one
SELECT
    SUM(CASE WHEN reaction = 'like' THEN 1 ELSE 0 END) AS likes,
    SUM(CASE WHEN reaction = 'dislike' THEN 1 ELSE 0 END) AS dislikes
FROM chapter_comment_reactions
WHERE comment_id = ?
`

type CountChapterReactionsRow struct {
	Likes    sql.NullFloat64
	Dislikes sql.NullFloat64
}

func (q *Queries) CountChapterReactions(ctx context.Context, commentID int64) (CountChapterReactionsRow, error) {
	row := q.db.QueryRowContext(ctx, countChapterReactions, commentID)
	var i CountChapterReactionsRow
	err := row.Scan(&i.Likes, &i.Dislikes)
	return i, err
}

const createChapterComment = `-- name: CreateChapterComment :one
INSERT INTO chapter_comments (
    chapter_id, user_id, parent_id, content, last_updated
) VALUES (
    ?, ?, ?, ?, ?
)
RETURNING id, chapter_id, user_id, parent_id, content, last_updated
`

type CreateChapterCommentParams struct {
	ChapterID   int64
	UserID      int64
	ParentID    sql.NullInt64
	Content     string
	LastUpdated string
}

func (q *Queries) CreateChapterComment(ctx context.Context, arg CreateChapterCommentParams) (ChapterComment, error) {
	row := q.db.QueryRowContext(ctx, createChapterComment,
		arg.ChapterID,
		arg.UserID,
		arg.ParentID,
		arg.Content,
		arg.LastUpdated,
	)
	var i ChapterComment
	err := row.Scan(
		&i.ID,
		&i.ChapterID,
		&i.UserID,
		&i.ParentID,
		&i.Content,
		&i.LastUpdated,
	)
	return i, err
}

const deleteChapterComment = `-- name: DeleteChapterComment :exec
DELETE FROM chapter_comments WHERE id = ? AND user_id = ?
`

type DeleteChapterCommentParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteChapterComment(ctx context.Context, arg DeleteChapterCommentParams) error {
	_, err := q.db.ExecContext(ctx, deleteChapterComment, arg.ID, arg.UserID)
	return err
}

const deleteChapterReactionIfSame = `-- name: DeleteChapterReactionIfSame :one

DELETE FROM chapter_comment_reactions
WHERE user_id = ? AND comment_id = ? AND reaction = ?
RETURNING 1
`

type DeleteChapterReactionIfSameParams struct {
	UserID    int64
	CommentID int64
	Reaction  string
}

// -------------------------------------
// USER REACTIONS
// -------------------------------------
func (q *Queries) DeleteChapterReactionIfSame(ctx context.Context, arg DeleteChapterReactionIfSameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteChapterReactionIfSame, arg.UserID, arg.CommentID, arg.Reaction)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getChapterCommentById = `-- name: GetChapterCommentById :one
SELECT id, chapter_id, user_id, parent_id, content, last_updated FROM chapter_comments WHERE id = ?
`

func (q *Queries) GetChapterCommentById(ctx context.Context, id int64) (ChapterComment, error) {
	row := q.db.QueryRowContext(ctx, getChapterCommentById, id)
	var i ChapterComment
	err := row.Scan(
		&i.ID,
		&i.ChapterID,
		&i.UserID,
		&i.ParentID,
		&i.Content,
		&i.LastUpdated,
	)
	return i, err
}

const getCommentsByChapter = `-- name: GetCommentsByChapter :many
SELECT c.id, c.chapter_id, c.user_id, c.parent_id, c.content, c.last_updated,
       u.username,
       u.image AS picture_url,
       (SELECT COUNT(*) FROM chapter_comment_reactions r WHERE r.comment_id = c.id AND r.reaction = 'like') AS likes,
       (SELECT COUNT(*) FROM chapter_comment_reactions r WHERE r.comment_id = c.id AND r.reaction = 'dislike') AS dislikes
FROM chapter_comments c
JOIN users u ON u.id = c.user_id
WHERE c.chapter_id = ?
ORDER BY c.last_updated ASC
`

type GetCommentsByChapterRow struct {
	ID          int64
	ChapterID   int64
	UserID      int64
	ParentID    sql.NullInt64
	Content     string
	LastUpdated string
	Username    string
	PictureUrl  string
	Likes       int64
	Dislikes    int64
}

func (q *Queries) GetCommentsByChapter(ctx context.Context, chapterID int64) ([]GetCommentsByChapterRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsByChapter, chapterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsByChapterRow
	for rows.Next() {
		var i GetCommentsByChapterRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.ParentID,
			&i.Content,
			&i.LastUpdated,
			&i.Username,
			&i.PictureUrl,
			&i.Likes,
			&i.Dislikes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCommentsByChapterWithUserReactions = `-- name: GetCommentsByChapterWithUserReactions :many
SELECT
    c.id, c.chapter_id, c.user_id, c.parent_id, c.content, c.last_updated,
    u.username,
    u.image AS picture_url,
    (SELECT COUNT(*) FROM chapter_comment_reactions
       WHERE comment_id = c.id AND reaction = 'like') AS likes,
    (SELECT COUNT(*) FROM chapter_comment_reactions
       WHERE comment_id = c.id AND reaction = 'dislike') AS dislikes,
    ur.reaction AS user_reaction
FROM chapter_comments c
JOIN users u ON u.id = c.user_id
LEFT JOIN chapter_comment_reactions ur
       ON ur.comment_id = c.id
      AND ur.user_id = ?
WHERE c.chapter_id = ?
ORDER BY c.last_updated ASC
`

type GetCommentsByChapterWithUserReactionsParams struct {
	UserID    int64
	ChapterID int64
}

type GetCommentsByChapterWithUserReactionsRow struct {
	ID           int64
	ChapterID    int64
	UserID       int64
	ParentID     sql.NullInt64
	Content      string
	LastUpdated  string
	Username     string
	PictureUrl   string
	Likes        int64
	Dislikes     int64
	UserReaction sql.NullString
}

func (q *Queries) GetCommentsByChapterWithUserReactions(ctx context.Context, arg GetCommentsByChapterWithUserReactionsParams) ([]GetCommentsByChapterWithUserReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsByChapterWithUserReactions, arg.UserID, arg.ChapterID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsByChapterWithUserReactionsRow
	for rows.Next() {
		var i GetCommentsByChapterWithUserReactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.ParentID,
			&i.Content,
			&i.LastUpdated,
			&i.Username,
			&i.PictureUrl,
			&i.Likes,
			&i.Dislikes,
			&i.UserReaction,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepliesByChapterComment = `-- name: GetRepliesByChapterComment :many
SELECT c.id, c.chapter_id, c.user_id, c.parent_id, c.content, c.last_updated,
       u.username,
       u.image AS picture_url,
       (SELECT COUNT(*) FROM chapter_comment_reactions r WHERE r.comment_id = c.id AND r.reaction = 'like') AS likes,
       (SELECT COUNT(*) FROM chapter_comment_reactions r WHERE r.comment_id = c.id AND r.reaction = 'dislike') AS dislikes
FROM chapter_comments c
JOIN users u ON u.id = c.user_id
WHERE c.parent_id = ?
ORDER BY c.last_updated ASC
`

type GetRepliesByChapterCommentRow struct {
	ID          int64
	ChapterID   int64
	UserID      int64
	ParentID    sql.NullInt64
	Content     string
	LastUpdated string
	Username    string
	PictureUrl  string
	Likes       int64
	Dislikes    int64
}

func (q *Queries) GetRepliesByChapterComment(ctx context.Context, parentID sql.NullInt64) ([]GetRepliesByChapterCommentRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepliesByChapterComment, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepliesByChapterCommentRow
	for rows.Next() {
		var i GetRepliesByChapterCommentRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.ParentID,
			&i.Content,
			&i.LastUpdated,
			&i.Username,
			&i.PictureUrl,
			&i.Likes,
			&i.Dislikes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepliesByChapterCommentWithUserReactions = `-- name: GetRepliesByChapterCommentWithUserReactions :many
SELECT
    c.id, c.chapter_id, c.user_id, c.parent_id, c.content, c.last_updated,
    u.username,
    u.image AS picture_url,
    (SELECT COUNT(*) FROM chapter_comment_reactions
       WHERE comment_id = c.id AND reaction = 'like') AS likes,
    (SELECT COUNT(*) FROM chapter_comment_reactions
       WHERE comment_id = c.id AND reaction = 'dislike') AS dislikes,
    ur.reaction AS user_reaction
FROM chapter_comments c
JOIN users u ON u.id = c.user_id
LEFT JOIN chapter_comment_reactions ur
       ON ur.comment_id = c.id
      AND ur.user_id = ?
WHERE c.parent_id = ?
ORDER BY c.last_updated ASC
`

type GetRepliesByChapterCommentWithUserReactionsParams struct {
	UserID   int64
	ParentID sql.NullInt64
}

type GetRepliesByChapterCommentWithUserReactionsRow struct {
	ID           int64
	ChapterID    int64
	UserID       int64
	ParentID     sql.NullInt64
	Content      string
	LastUpdated  string
	Username     string
	PictureUrl   string
	Likes        int64
	Dislikes     int64
	UserReaction sql.NullString
}

func (q *Queries) GetRepliesByChapterCommentWithUserReactions(ctx context.Context, arg GetRepliesByChapterCommentWithUserReactionsParams) ([]GetRepliesByChapterCommentWithUserReactionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepliesByChapterCommentWithUserReactions, arg.UserID, arg.ParentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepliesByChapterCommentWithUserReactionsRow
	for rows.Next() {
		var i GetRepliesByChapterCommentWithUserReactionsRow
		if err := rows.Scan(
			&i.ID,
			&i.ChapterID,
			&i.UserID,
			&i.ParentID,
			&i.Content,
			&i.LastUpdated,
			&i.Username,
			&i.PictureUrl,
			&i.Likes,
			&i.Dislikes,
			&i.UserReaction,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserChapterReaction = `-- name: GetUserChapterReaction :one
SELECT reaction
FROM chapter_comment_reactions
WHERE user_id = ? AND comment_id = ?
`

type GetUserChapterReactionParams struct {
	UserID    int64
	CommentID int64
}

func (q *Queries) GetUserChapterReaction(ctx context.Context, arg GetUserChapterReactionParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserChapterReaction, arg.UserID, arg.CommentID)
	var reaction string
	err := row.Scan(&reaction)
	return reaction, err
}

const getUserReactionsForChapterComments = `-- name: GetUserReactionsForChapterComments :many
SELECT 
    comment_id,
    reaction
FROM chapter_comment_reactions
WHERE user_id = ? AND comment_id IN (/*SLICE:comment_ids*/?)
`

type GetUserReactionsForChapterCommentsParams struct {
	UserID     int64
	CommentIds []int64
}

type GetUserReactionsForChapterCommentsRow struct {
	CommentID int64
	Reaction  string
}

func (q *Queries) GetUserReactionsForChapterComments(ctx context.Context, arg GetUserReactionsForChapterCommentsParams) ([]GetUserReactionsForChapterCommentsRow, error) {
	query := getUserReactionsForChapterComments
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UserID)
	if len(arg.CommentIds) > 0 {
		for _, v := range arg.CommentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:comment_ids*/?", strings.Repeat(",?", len(arg.CommentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:comment_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserReactionsForChapterCommentsRow
	for rows.Next() {
		var i GetUserReactionsForChapterCommentsRow
		if err := rows.Scan(&i.CommentID, &i.Reaction); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeChapterReaction = `-- name: RemoveChapterReaction :exec
DELETE FROM chapter_comment_reactions
WHERE user_id = ? AND comment_id = ?
`

type RemoveChapterReactionParams struct {
	UserID    int64
	CommentID int64
}

func (q *Queries) RemoveChapterReaction(ctx context.Context, arg RemoveChapterReactionParams) error {
	_, err := q.db.ExecContext(ctx, removeChapterReaction, arg.UserID, arg.CommentID)
	return err
}

const updateChapterComment = `-- name: UpdateChapterComment :one
UPDATE chapter_comments
SET 
    content = ?, 
    last_updated = ?
WHERE id = ?
RETURNING id, chapter_id, user_id, parent_id, content, last_updated
`

type UpdateChapterCommentParams struct {
	Content     string
	LastUpdated string
	ID          int64
}

func (q *Queries) UpdateChapterComment(ctx context.Context, arg UpdateChapterCommentParams) (ChapterComment, error) {
	row := q.db.QueryRowContext(ctx, updateChapterComment, arg.Content, arg.LastUpdated, arg.ID)
	var i ChapterComment
	err := row.Scan(
		&i.ID,
		&i.ChapterID,
		&i.UserID,
		&i.ParentID,
		&i.Content,
		&i.LastUpdated,
	)
	return i, err
}

const upsertChapterReaction = `-- name: UpsertChapterReaction :exec
INSERT INTO chapter_comment_reactions (user_id, comment_id, reaction, last_updated)
VALUES (?, ?, ?, ?)
ON CONFLICT(user_id, comment_id) DO UPDATE
SET reaction = excluded.reaction,
    last_updated = excluded.last_updated
`

type UpsertChapterReactionParams struct {
	UserID      int64
	CommentID   int64
	Reaction    string
	LastUpdated string
}

func (q *Queries) UpsertChapterReaction(ctx context.Context, arg UpsertChapterReactionParams) error {
	_, err := q.db.ExecContext(ctx, upsertChapterReaction,
		arg.UserID,
		arg.CommentID,
		arg.Reaction,
		arg.LastUpdated,
	)
	return err
}
