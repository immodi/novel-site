// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tags.sql

package repositories

import (
	"context"
)

const addTagToNovel = `-- name: AddTagToNovel :exec
INSERT INTO novel_tags (novel_id, tag)
VALUES (?, ?)
ON CONFLICT(novel_id, tag) DO NOTHING
`

type AddTagToNovelParams struct {
	NovelID int64
	Tag     string
}

func (q *Queries) AddTagToNovel(ctx context.Context, arg AddTagToNovelParams) error {
	_, err := q.db.ExecContext(ctx, addTagToNovel, arg.NovelID, arg.Tag)
	return err
}

const countNovelsByTag = `-- name: CountNovelsByTag :one
SELECT COUNT(*)
FROM novel_tags
WHERE tag = ?
`

func (q *Queries) CountNovelsByTag(ctx context.Context, tag string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNovelsByTag, tag)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteAllTagsByNovel = `-- name: DeleteAllTagsByNovel :exec
DELETE FROM novel_tags
WHERE novel_id = ?
`

func (q *Queries) DeleteAllTagsByNovel(ctx context.Context, novelID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllTagsByNovel, novelID)
	return err
}

const listNovelsByTag = `-- name: ListNovelsByTag :many
SELECT n.id, n.title, n.description, n.cover_image, n.author, n.publisher, n.release_year, n.is_completed, n.update_time, n.view_count
FROM novels n
JOIN novel_tags t ON n.id = t.novel_id
WHERE t.tag = ?
ORDER BY n.update_time DESC
`

func (q *Queries) ListNovelsByTag(ctx context.Context, tag string) ([]Novel, error) {
	rows, err := q.db.QueryContext(ctx, listNovelsByTag, tag)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Novel
	for rows.Next() {
		var i Novel
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Author,
			&i.Publisher,
			&i.ReleaseYear,
			&i.IsCompleted,
			&i.UpdateTime,
			&i.ViewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNovelsByTagPaginated = `-- name: ListNovelsByTagPaginated :many
SELECT n.id, n.title, n.description, n.cover_image, n.author, n.publisher, n.release_year, n.is_completed, n.update_time, n.view_count
FROM novels n
JOIN novel_tags t ON n.id = t.novel_id
WHERE t.tag = ?
ORDER BY n.update_time DESC
LIMIT ? OFFSET ?
`

type ListNovelsByTagPaginatedParams struct {
	Tag    string
	Limit  int64
	Offset int64
}

func (q *Queries) ListNovelsByTagPaginated(ctx context.Context, arg ListNovelsByTagPaginatedParams) ([]Novel, error) {
	rows, err := q.db.QueryContext(ctx, listNovelsByTagPaginated, arg.Tag, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Novel
	for rows.Next() {
		var i Novel
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.CoverImage,
			&i.Author,
			&i.Publisher,
			&i.ReleaseYear,
			&i.IsCompleted,
			&i.UpdateTime,
			&i.ViewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByNovel = `-- name: ListTagsByNovel :many
SELECT tag
FROM novel_tags
WHERE novel_id = ?
ORDER BY tag ASC
`

func (q *Queries) ListTagsByNovel(ctx context.Context, novelID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByNovel, novelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTagFromNovel = `-- name: RemoveTagFromNovel :exec
DELETE FROM novel_tags
WHERE novel_id = ? AND tag = ?
`

type RemoveTagFromNovelParams struct {
	NovelID int64
	Tag     string
}

func (q *Queries) RemoveTagFromNovel(ctx context.Context, arg RemoveTagFromNovelParams) error {
	_, err := q.db.ExecContext(ctx, removeTagFromNovel, arg.NovelID, arg.Tag)
	return err
}
