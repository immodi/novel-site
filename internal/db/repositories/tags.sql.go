// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tags.sql

package repositories

import (
	"context"
)

const addTagToNovel = `-- name: AddTagToNovel :exec
INSERT INTO novel_tags (novel_id, tag, tag_slug)
VALUES (?, ?, ?)
ON CONFLICT(novel_id, tag) DO NOTHING
`

type AddTagToNovelParams struct {
	NovelID int64
	Tag     string
	TagSlug string
}

func (q *Queries) AddTagToNovel(ctx context.Context, arg AddTagToNovelParams) error {
	_, err := q.db.ExecContext(ctx, addTagToNovel, arg.NovelID, arg.Tag, arg.TagSlug)
	return err
}

const countNovelsByTag = `-- name: CountNovelsByTag :one
SELECT COUNT(*)
FROM novel_tags
WHERE tag_slug = ?
`

func (q *Queries) CountNovelsByTag(ctx context.Context, tagSlug string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countNovelsByTag, tagSlug)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteAllTagsByNovel = `-- name: DeleteAllTagsByNovel :exec
DELETE FROM novel_tags
WHERE novel_id = ?
`

func (q *Queries) DeleteAllTagsByNovel(ctx context.Context, novelID int64) error {
	_, err := q.db.ExecContext(ctx, deleteAllTagsByNovel, novelID)
	return err
}

const getTagBySlug = `-- name: GetTagBySlug :one
SELECT novel_id, tag, tag_slug
FROM novel_tags
WHERE tag_slug = ?
LIMIT 1
`

func (q *Queries) GetTagBySlug(ctx context.Context, tagSlug string) (NovelTag, error) {
	row := q.db.QueryRowContext(ctx, getTagBySlug, tagSlug)
	var i NovelTag
	err := row.Scan(&i.NovelID, &i.Tag, &i.TagSlug)
	return i, err
}

const listAllTagSlugs = `-- name: ListAllTagSlugs :many
SELECT DISTINCT tag_slug
FROM novel_tags
ORDER BY tag COLLATE NOCASE
`

func (q *Queries) ListAllTagSlugs(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAllTagSlugs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag_slug string
		if err := rows.Scan(&tag_slug); err != nil {
			return nil, err
		}
		items = append(items, tag_slug)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllTags = `-- name: ListAllTags :many
SELECT DISTINCT tag
FROM novel_tags
ORDER BY tag COLLATE NOCASE
`

func (q *Queries) ListAllTags(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listAllTags)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNovelsByTag = `-- name: ListNovelsByTag :many
SELECT n.id, n.title, n.slug, n.description, n.cover_image, n.author, n.author_slug, n.publisher, n.release_year, n.is_completed, n.update_time, n.view_count
FROM novels n
JOIN novel_tags t ON n.id = t.novel_id
WHERE t.tag_slug = ?
ORDER BY n.update_time DESC
`

func (q *Queries) ListNovelsByTag(ctx context.Context, tagSlug string) ([]Novel, error) {
	rows, err := q.db.QueryContext(ctx, listNovelsByTag, tagSlug)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Novel
	for rows.Next() {
		var i Novel
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.CoverImage,
			&i.Author,
			&i.AuthorSlug,
			&i.Publisher,
			&i.ReleaseYear,
			&i.IsCompleted,
			&i.UpdateTime,
			&i.ViewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listNovelsByTagPaginated = `-- name: ListNovelsByTagPaginated :many
SELECT n.id, n.title, n.slug, n.description, n.cover_image, n.author, n.author_slug, n.publisher, n.release_year, n.is_completed, n.update_time, n.view_count
FROM novels n
JOIN novel_tags t ON n.id = t.novel_id
WHERE t.tag_slug = ?
ORDER BY n.update_time DESC
LIMIT ? OFFSET ?
`

type ListNovelsByTagPaginatedParams struct {
	TagSlug string
	Limit   int64
	Offset  int64
}

func (q *Queries) ListNovelsByTagPaginated(ctx context.Context, arg ListNovelsByTagPaginatedParams) ([]Novel, error) {
	rows, err := q.db.QueryContext(ctx, listNovelsByTagPaginated, arg.TagSlug, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Novel
	for rows.Next() {
		var i Novel
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Slug,
			&i.Description,
			&i.CoverImage,
			&i.Author,
			&i.AuthorSlug,
			&i.Publisher,
			&i.ReleaseYear,
			&i.IsCompleted,
			&i.UpdateTime,
			&i.ViewCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByName = `-- name: ListTagsByName :many
SELECT DISTINCT tag
FROM novel_tags
WHERE LOWER(tag) LIKE LOWER(?)
ORDER BY tag ASC
LIMIT 20
`

func (q *Queries) ListTagsByName(ctx context.Context, lower string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByName, lower)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag string
		if err := rows.Scan(&tag); err != nil {
			return nil, err
		}
		items = append(items, tag)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTagsByNovel = `-- name: ListTagsByNovel :many
SELECT novel_id, tag, tag_slug
FROM novel_tags
WHERE novel_id = ?
ORDER BY tag ASC
`

func (q *Queries) ListTagsByNovel(ctx context.Context, novelID int64) ([]NovelTag, error) {
	rows, err := q.db.QueryContext(ctx, listTagsByNovel, novelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []NovelTag
	for rows.Next() {
		var i NovelTag
		if err := rows.Scan(&i.NovelID, &i.Tag, &i.TagSlug); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeTagFromNovel = `-- name: RemoveTagFromNovel :exec
DELETE FROM novel_tags
WHERE novel_id = ? AND tag = ?
`

type RemoveTagFromNovelParams struct {
	NovelID int64
	Tag     string
}

func (q *Queries) RemoveTagFromNovel(ctx context.Context, arg RemoveTagFromNovelParams) error {
	_, err := q.db.ExecContext(ctx, removeTagFromNovel, arg.NovelID, arg.Tag)
	return err
}
