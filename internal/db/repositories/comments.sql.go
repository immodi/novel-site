// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: comments.sql

package repositories

import (
	"context"
	"database/sql"
	"strings"
)

const countReactions = `-- name: CountReactions :one
SELECT
    SUM(CASE WHEN reaction = 'like' THEN 1 ELSE 0 END) AS likes,
    SUM(CASE WHEN reaction = 'dislike' THEN 1 ELSE 0 END) AS dislikes
FROM comment_reactions
WHERE comment_id = ?
`

type CountReactionsRow struct {
	Likes    sql.NullFloat64
	Dislikes sql.NullFloat64
}

func (q *Queries) CountReactions(ctx context.Context, commentID int64) (CountReactionsRow, error) {
	row := q.db.QueryRowContext(ctx, countReactions, commentID)
	var i CountReactionsRow
	err := row.Scan(&i.Likes, &i.Dislikes)
	return i, err
}

const createComment = `-- name: CreateComment :one
INSERT INTO comments (
    novel_id, user_id, parent_id, content, last_updated
) VALUES (
    ?, ?, ?, ?, ?
)
RETURNING id, novel_id, user_id, parent_id, content, last_updated
`

type CreateCommentParams struct {
	NovelID     int64
	UserID      int64
	ParentID    sql.NullInt64
	Content     string
	LastUpdated string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.NovelID,
		arg.UserID,
		arg.ParentID,
		arg.Content,
		arg.LastUpdated,
	)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.NovelID,
		&i.UserID,
		&i.ParentID,
		&i.Content,
		&i.LastUpdated,
	)
	return i, err
}

const deleteComment = `-- name: DeleteComment :exec
DELETE FROM comments WHERE id = ? AND user_id = ?
`

type DeleteCommentParams struct {
	ID     int64
	UserID int64
}

func (q *Queries) DeleteComment(ctx context.Context, arg DeleteCommentParams) error {
	_, err := q.db.ExecContext(ctx, deleteComment, arg.ID, arg.UserID)
	return err
}

const deleteReactionIfSame = `-- name: DeleteReactionIfSame :one

DELETE FROM comment_reactions
WHERE user_id = ? AND comment_id = ? AND reaction = ?
RETURNING 1
`

type DeleteReactionIfSameParams struct {
	UserID    int64
	CommentID int64
	Reaction  string
}

// -------------------------------------
// USER REACTIONS
// -------------------------------------
func (q *Queries) DeleteReactionIfSame(ctx context.Context, arg DeleteReactionIfSameParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, deleteReactionIfSame, arg.UserID, arg.CommentID, arg.Reaction)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const getCommentById = `-- name: GetCommentById :one
SELECT id, novel_id, user_id, parent_id, content, last_updated FROM comments WHERE id = ?
`

func (q *Queries) GetCommentById(ctx context.Context, id int64) (Comment, error) {
	row := q.db.QueryRowContext(ctx, getCommentById, id)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.NovelID,
		&i.UserID,
		&i.ParentID,
		&i.Content,
		&i.LastUpdated,
	)
	return i, err
}

const getCommentsByNovel = `-- name: GetCommentsByNovel :many
SELECT c.id, c.novel_id, c.user_id, c.parent_id, c.content, c.last_updated,
       u.username,
       u.image AS picture_url,
       (SELECT COUNT(*) FROM comment_reactions r WHERE r.comment_id = c.id AND r.reaction = 'like') AS likes,
       (SELECT COUNT(*) FROM comment_reactions r WHERE r.comment_id = c.id AND r.reaction = 'dislike') AS dislikes
FROM comments c
JOIN users u ON u.id = c.user_id
WHERE c.novel_id = ?
ORDER BY c.last_updated ASC
`

type GetCommentsByNovelRow struct {
	ID          int64
	NovelID     int64
	UserID      int64
	ParentID    sql.NullInt64
	Content     string
	LastUpdated string
	Username    string
	PictureUrl  string
	Likes       int64
	Dislikes    int64
}

func (q *Queries) GetCommentsByNovel(ctx context.Context, novelID int64) ([]GetCommentsByNovelRow, error) {
	rows, err := q.db.QueryContext(ctx, getCommentsByNovel, novelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsByNovelRow
	for rows.Next() {
		var i GetCommentsByNovelRow
		if err := rows.Scan(
			&i.ID,
			&i.NovelID,
			&i.UserID,
			&i.ParentID,
			&i.Content,
			&i.LastUpdated,
			&i.Username,
			&i.PictureUrl,
			&i.Likes,
			&i.Dislikes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRepliesByComment = `-- name: GetRepliesByComment :many
SELECT c.id, c.novel_id, c.user_id, c.parent_id, c.content, c.last_updated,
       u.username,
       u.image AS picture_url,
       (SELECT COUNT(*) FROM comment_reactions r WHERE r.comment_id = c.id AND r.reaction = 'like') AS likes,
       (SELECT COUNT(*) FROM comment_reactions r WHERE r.comment_id = c.id AND r.reaction = 'dislike') AS dislikes
FROM comments c
JOIN users u ON u.id = c.user_id
WHERE c.parent_id = ?
ORDER BY c.last_updated ASC
`

type GetRepliesByCommentRow struct {
	ID          int64
	NovelID     int64
	UserID      int64
	ParentID    sql.NullInt64
	Content     string
	LastUpdated string
	Username    string
	PictureUrl  string
	Likes       int64
	Dislikes    int64
}

func (q *Queries) GetRepliesByComment(ctx context.Context, parentID sql.NullInt64) ([]GetRepliesByCommentRow, error) {
	rows, err := q.db.QueryContext(ctx, getRepliesByComment, parentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRepliesByCommentRow
	for rows.Next() {
		var i GetRepliesByCommentRow
		if err := rows.Scan(
			&i.ID,
			&i.NovelID,
			&i.UserID,
			&i.ParentID,
			&i.Content,
			&i.LastUpdated,
			&i.Username,
			&i.PictureUrl,
			&i.Likes,
			&i.Dislikes,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserReaction = `-- name: GetUserReaction :one
SELECT reaction
FROM comment_reactions
WHERE user_id = ? AND comment_id = ?
`

type GetUserReactionParams struct {
	UserID    int64
	CommentID int64
}

func (q *Queries) GetUserReaction(ctx context.Context, arg GetUserReactionParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserReaction, arg.UserID, arg.CommentID)
	var reaction string
	err := row.Scan(&reaction)
	return reaction, err
}

const getUserReactionsForComments = `-- name: GetUserReactionsForComments :many
SELECT 
    comment_id,
    reaction
FROM comment_reactions
WHERE user_id = ? AND comment_id IN (/*SLICE:comment_ids*/?)
`

type GetUserReactionsForCommentsParams struct {
	UserID     int64
	CommentIds []int64
}

type GetUserReactionsForCommentsRow struct {
	CommentID int64
	Reaction  string
}

func (q *Queries) GetUserReactionsForComments(ctx context.Context, arg GetUserReactionsForCommentsParams) ([]GetUserReactionsForCommentsRow, error) {
	query := getUserReactionsForComments
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UserID)
	if len(arg.CommentIds) > 0 {
		for _, v := range arg.CommentIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:comment_ids*/?", strings.Repeat(",?", len(arg.CommentIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:comment_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserReactionsForCommentsRow
	for rows.Next() {
		var i GetUserReactionsForCommentsRow
		if err := rows.Scan(&i.CommentID, &i.Reaction); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeReaction = `-- name: RemoveReaction :exec
DELETE FROM comment_reactions
WHERE user_id = ? AND comment_id = ?
`

type RemoveReactionParams struct {
	UserID    int64
	CommentID int64
}

func (q *Queries) RemoveReaction(ctx context.Context, arg RemoveReactionParams) error {
	_, err := q.db.ExecContext(ctx, removeReaction, arg.UserID, arg.CommentID)
	return err
}

const updateComment = `-- name: UpdateComment :one
UPDATE comments
SET 
    content = ?, 
    last_updated = ?
WHERE id = ?
RETURNING id, novel_id, user_id, parent_id, content, last_updated
`

type UpdateCommentParams struct {
	Content     string
	LastUpdated string
	ID          int64
}

func (q *Queries) UpdateComment(ctx context.Context, arg UpdateCommentParams) (Comment, error) {
	row := q.db.QueryRowContext(ctx, updateComment, arg.Content, arg.LastUpdated, arg.ID)
	var i Comment
	err := row.Scan(
		&i.ID,
		&i.NovelID,
		&i.UserID,
		&i.ParentID,
		&i.Content,
		&i.LastUpdated,
	)
	return i, err
}

const upsertReaction = `-- name: UpsertReaction :exec
INSERT INTO comment_reactions (user_id, comment_id, reaction, last_updated)
VALUES (?, ?, ?, ?)
ON CONFLICT(user_id, comment_id) DO UPDATE
SET reaction = excluded.reaction,
    last_updated = excluded.last_updated
`

type UpsertReactionParams struct {
	UserID      int64
	CommentID   int64
	Reaction    string
	LastUpdated string
}

func (q *Queries) UpsertReaction(ctx context.Context, arg UpsertReactionParams) error {
	_, err := q.db.ExecContext(ctx, upsertReaction,
		arg.UserID,
		arg.CommentID,
		arg.Reaction,
		arg.LastUpdated,
	)
	return err
}
